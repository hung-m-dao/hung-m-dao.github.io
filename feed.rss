<?xml version="1.0" encoding="UTF-8"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/"><channel><title>My blog</title><description>Hello! I'm Hung, and this is my personal space.</description><link>https://hung-m-dao.github.io/</link><language>en</language><lastBuildDate>Wed, 30 Mar 2022 12:45:05 +0000</lastBuildDate><pubDate>Wed, 30 Mar 2022 12:45:05 +0000</pubDate><ttl>250</ttl><atom:link href="https://hung-m-dao.github.io/feed.rss" rel="self" type="application/rss+xml"/><item><guid isPermaLink="true">https://hung-m-dao.github.io/hung/md-to-html</guid><title>Làm Blog bằng Publish - Xuất HTML từ file Markdown</title><description>Thay vì ngủ lúc 10h thì mình đã thức đến 1h để làm gì ?</description><link>https://hung-m-dao.github.io/hung/md-to-html</link><pubDate>Fri, 25 Mar 2022 11:55:00 +0000</pubDate><content:encoded><![CDATA[<h1>Làm Blog bằng Publish - Xuất HTML từ file Markdown</h1><p>Mình viết blog này bằng <a href="https://github.com/JohnSundell/Publish">Publish</a>, nó là một công cụ giúp tạo ra những trang web tĩnh, dành cho những lập trình viên sử dụng Swift. Chi tiết hơn về Publish sẽ được trình bày trong bài viết khác, bài viết này sẽ nói về hành trình mình tìm giải pháp xuất HTML của mình.</p><h3>Tại sao phải xuất HTML ?</h3><p>Publish vốn có thể tự động parse file Markdown thành HTML, thông qua <a href="https://github.com/JohnSundell/Ink">Ink</a> - một công cụ cũng do tác giả của Publish viết. Tuy nhiên, công cụ này còn rất nhiều thiếu sót (chính tác giả cũng nói vậy), và có rất nhiều tính năng của Markdown không parse được thành HTML (nested block, list in block,... ). Do đó mình bắt đầu đi tìm giải pháp tốt hơn để tạo ra file HTML (vì Publish cũng support raw HTML).</p><h3>Typora</h3><p>Sau khi tham khảo nhiều Markdown editor thì mình quyết định bắt đầu với <a href="https://typora.io/">Typora</a>, một công cụ được recommend rất nhiều. Typora có rất nhiều ưu điểm, như giao diện tối giản, xuất được rất nhiều định dạng file, đặc biệt có thể xuất HTML without styles - thứ mình rất cần.</p><p>Tuy nhiên, vì những nhược điểm sau, mà mình đã không chọn Typora:</p><ul>
<li>Tốn phí, $15.</li>
<li>Mình cần side panel để preview, nhưng không có option này.</li>
<li>Kiểu edit WYSIWYG làm mình khó chịu, loay hoay 2 phút cũng không xóa được 1 code block.</li>
</ul><h3>Quay đầu là bờ</h3><p>Loay hoay thêm 1 lúc với nhiều Markdown editor khác nhưng vẫn không ưng, mình nhớ ra VSCode và quyết định thử với nó. VSCode đã có sẵn rất nhiều thứ mình cần: Vim keybindings, side panel preview, theme/font configurations... . Nhưng có một thứ rất quan trọng mà VSCode đang thiếu: xuất HTML without styles.</p><p>Mình có thử google và thấy <a href="https://code.visualstudio.com/docs/languages/markdown#_compiling-markdown-into-html">hướng dẫn</a> của chính VSCode, nhưng có vẻ hơi phức tạp nên mình để lại thử sau. Sau khi thử với nhiều Markdown extension khác nhau, mình vẫn không có được kết quả như ý, vì cùng 1 lí do: những extension này không có option xuất HTML <strong>without styles</strong>. Mình đành quay lại đọc hướng dẫn &quot;chính chủ&quot;.</p><h3>markdown-it</h3><p>Đọc hướng dẫn của VSCode thì mình thấy họ dùng command <a href="https://github.com/markdown-it/markdown-it">markdown-it</a> để làm ví dụ. Mình có vào xem github thì thấy đây là một thư viện của NodeJs, có kèm theo CLI, và rất dễ sử dụng. Mình mừng như cá gặp nước và nhanh chóng bắt tay vào setup.</p><p>Sau vài sự tìm kiếm thì extension mình đã dùng là <a href="https://marketplace.visualstudio.com/items?itemName=edonet.vscode-command-runner">Command Runner</a>, nó cho phép mình bind shortcut key đến một command đã được định nghĩa trước. Đây là đoạn config mình dùng để định nghĩa command, được thêm vào file <code>settings.json</code> của VSCode:</p><pre><code class="language-json"> &quot;command-runner.terminal.name&quot;: &quot;runCommand&quot;,
    &quot;command-runner.terminal.autoClear&quot;: true,
    &quot;command-runner.terminal.autoFocus&quot;: true,
    &quot;command-runner.commands&quot;: {
        &quot;Export Markdown to HTML&quot;: &quot;cd ${fileDirname} &amp;&amp; markdown-it ${fileBasename} -o ${fileBasenameNoExtension}.html&quot;,
    },
</code></pre><p>Và để bind với shortcut thì mình đã thêm vào <code>keybindings.json</code>:</p><pre><code class="language-json">[
    {
        &quot;key&quot;: &quot;ctrl+cmd+e&quot;,
        &quot;command&quot;: &quot;command-runner.run&quot;,
        &quot;args&quot;: {
            &quot;command&quot;: &quot;Export Markdown to HTML&quot;,
            &quot;terminal&quot;: &quot;runCommand&quot;
        }
    }
]
</code></pre><p>Như vậy, mỗi lần soạn xong file Markdown, thì mình chỉ cần nhấn Ctrl+Cmd+E thì sẽ có một file HTML cùng tên được xuất ra ở cùng thư mục.</p><h3>30 chưa phải là Tết</h3><p>Tưởng chừng đã giải quyết được vấn đề và có thể đi ngủ, nhưng đời không như là mơ. Khi test thử với vài sample file thì mình đã phát hiện, <code>markdown-it</code> chưa hỗ trợ một số tính năng của Markdown, như foot-note, subscript, supscript,... . Sau khi quay lại xem document của họ, thì mình mới biết là cần dùng thêm <a href="https://github.com/markdown-it/markdown-it#syntax-extensions">syntax extensions</a> để dùng được những tính năng đó. Tuy nhiên không hề có hướng dẫn nào để load plugin cho CLI, mình tìm rất nhiều nhưng đều không có kết quả. Tới đây thì đã khá tuyệt vọng và buồn ngủ, mình đành tìm file binary của command đó xem source, hi vọng cuối. Để tìm &quot;nguồn gốc&quot; của <code>markdown-it</code>, mình dùng command:</p><pre><code class="language-bash">$ type -a markdown-it
</code></pre><p>và nhận được output <code>/usr/local/bin/markdown-it</code></p><p>Mình tìm đến directory trên và mở file binary lên, thật may là syntax dường như của JS, mình đã có thể load thêm plugin mà mình cần.</p><pre><code class="language-javascript">  md = require('..')({
    html: !options.no_html,
    xhtmlOut: false,
    typographer: options.typographer,
    linkify: options.linkify
  }).use(require('markdown-it-footnote'))
    .use(require('markdown-it-sub'))
    .use(require('markdown-it-sup'));
</code></pre><p>Voilà! Cuối cùng cũng đi ngủ được rồi.</p><h3>Kết</h3><p>Mặc dù có thể mình đã mắc phải <a href="https://en.wikipedia.org/wiki/XY_problem">XY Problem</a> khi cố đi tìm cách xuất file HTML, nhưng hành trình đi tìm giải pháp đã giúp mình học thêm và phát hiện được thêm khá nhiều thứ. Worth the effort ^^.</p>]]></content:encoded></item><item><guid isPermaLink="true">https://hung-m-dao.github.io/hung/collectors-fallacy</guid><title>Collector's fallacy</title><description>The reason why I bought 100+ games on Steam but only play ~5 of them.</description><link>https://hung-m-dao.github.io/hung/collectors-fallacy</link><pubDate>Fri, 25 Mar 2022 00:15:00 +0000</pubDate><content:encoded><![CDATA[<h1>Collector's fallacy</h1><h2>What is it ?</h2><p><strong>Collector’s Fallacy</strong><sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup> is the urge to collect something that you never use or need, but the act of collecting gives you a good feeling.
The sciene behind this, is,  each time we discover a new productivity toy, our brain sends us a jolt of <a href="https://en.wikipedia.org/wiki/Dopamine">dopamine</a> (our brain’s “reward” hormone)</p><h2>How to avoid it</h2><ul>
<li>&quot;Own&quot; before you collect</li>
</ul><p>Think it through before making any decision, take it slow.</p><ul>
<li>Purging</li>
</ul><p>Get rid of things you don't really touch. My rule of thumb: If you haven't used it in a year, throw it away.</p><ul>
<li>Measuring</li>
</ul><p>Always keep track of what you already have, remind yourself of the old items, this might help reduce the need of collecting new stuffs.</p><hr class="footnotes-sep">
<section class="footnotes">
<ol class="footnotes-list">
<li id="fn1" class="footnote-item"><p><em><a href="https://observer.com/2017/05/the-collectors-fallacy-why-we-gather-things-we-dont-need/">The Collector’s Fallacy: Why We Gather Things We Don’t Need</a></em> <a href="#fnref1" class="footnote-backref">↩︎</a></p>
</li>
</ol>
</section>
]]></content:encoded></item><item><guid isPermaLink="true">https://hung-m-dao.github.io/thao/go-interface</guid><title>GO INTERFACE</title><description>Go interface - The distinction makes the power and grace of Go</description><link>https://hung-m-dao.github.io/thao/go-interface</link><pubDate>Thu, 24 Mar 2022 16:55:00 +0000</pubDate><content:encoded><![CDATA[<h1>GO INTERFACE</h1><p>Giống như các ngôn ngữ lập trình khác, nơi mà chúng ta đều có thể tìm kiếm những khái niệm liên quan đến “Interface", với những ngôn ngữ hướng đối tượng kiểu tĩnh như Java, C# … thì cũng chính là interface, với những ngôn ngữ kiểu động thì có một khái niệm gần sát là “Duck Tying". Go interface cũng mang trong mình những đặc tính đó, nếu hiểu interface trong Java là “explicit interface" thì đối với Go nó là “implicit interface", trên hệ quy chiếu của các ngôn ngữ kiểu động thì có thể gọi Go Interface là Type-Safe Duck Typing. Điều đó nói lên điều gì ? Go không nghiêng về hẳn về một bên nào, mà ngược lại như một kẻ trung lập đứng ở giữa và chấp nhận quan điểm của cả hai trường phái, điều đó giúp cho Interface trong Go trở nên thật mạnh mẽ nhưng cũng thật tao nhã.</p><h2>1 Interface là gì và nó đang tồn tại như thể nào ?</h2><p>Để định nghĩa chính xác interface là gì không hề dễ, đây là một khái niệm gây confuse và được mô tả khác nhau ở các ngôn ngữ. Nhưng nó vẫn dựa trên một nền tảng chung nó là một kiểu thể hiện sự tổng quát hóa và trừu tượng hóa dựa trên các hành vi của các kiểu khác. Để hiểu rõ hơn ở đây mình sẽ dùng interface ở trong Java và Duck Typing trong python để làm rõ vấn đề ở trên ở mức độ ngôn ngữ</p><h3>1.1 Java Interface là Explicit Interface</h3><pre><code class="language-java">public interface Writer {
    void write(String data);
}

public class FileWriter implements Writer {
    public void write(String data) {
    // write string data to text file 
    }
}

public class Client {
    private final Writer writer;
    // this type is the interface, not the implementation

    public Client(Writer writer) {
      this.writer = writer;
    }

    public void program() {
        // get data from somewhere
        this.writer.write(data);
    }
}

public static void main(String[] args) {
    Writer writer = new FileWriter();
    Client client = new Client(writer);
    client.program();
}
</code></pre><ul><li>Trong Java khi một class muốn hiện thực một interface, thì cần phải đặc tả một cách “explicit" interface mà class đó muốn hiện thực.</li><li>Điều này có ưu điểm là tính readability cao giúp cho mọi người có thể nhanh chóng nắm bắt code đang muốn nói gì và đặc biệt với những người mói tiếp cận project.</li><li>Nhưng có một nhược điểm là tính flexible, chính vì việc cần đặc tả interface mà một class đang implement sẽ dẫn đến việc refactor code sẽ không hề dễ dàng hay có thể nói là khó khăn khi ứng dụng của chúng ta phát triển và thay đổi theo thời gian. Có thể nhìn vào đoạn code trên, giả sử chúng ta đang có <code>Writer</code> interface được import từ một thư viện vào đó, và tại thời điểm quyết định dùng nó mọi thứ rất tuyệt vời. Một thời gian sau, chúng ta có thêm requirement rằng hệ thống cần phải thêm chức năng ghi dữ liệu ra file .proto (một loại file mới xuất hiện gần đây) mà thư viện của writer interface chưa support. Vậy giải pháp ở đây là gì ? Chúng ta cần một thư viện mới hiện đại hơn có thể dùng được cho các loại file mới hơn và cũng như support các loại file đã tồn tại ở trong <code>Writer</code>, mình tạm gọi nó là <code>ModernWriter</code> interface. Tưởng chừng bài toán đã được giải quyết nhưng thật không may, nếu chuyển qua sử dụng thư viện mới này thì các đoạn code liên quan đến client cần phải được refactor để chuyển sang sử dụng interface mới hay có thể nói một cách vĩ mô hơn là client đang phụ thuộc vào các dependencies điều này đang đi ngược với nguyên tác Dependency Inversion của Uncle Bob trong SOLID, vì mỗi lần ta cần chuyển sang sử dụng thư viện mới ta lại phải can thiệp vào code của client và đó không phải là một ý kiến hay, vậy câu hỏi được đặt ra ở đây là có cách nào để giải quyết bài toán này một cách dễ dàng nhất trong Java ?</li></ul><h3>1.2 Duck Typing với Python</h3><p>Duck Typing rất phổ biến trong các ngôn ngữ kiểu động, nó được định nghĩa là một phương pháp lập trình từ ý tưởng của duck test ("If it looks like a duck, swims like a duck, and quacks like a duck, then it probably is a duck" - tạm dịch là nếu một thứ nào đó trông giống một con vịt, bơi như một con vịt, và kêu quạc quạc như vịt thì nó có thể là một con vịt). Nó có nghĩa việc lập trình của chúng ta bây giờ sẽ hướng tới hành vi của đối tượng hơn là kiểu của chúng. Vậy để hiểu rõ hơn về duck typing, mình sẽ dùng chính ví dụ ở trên được viết lại bằng Python để minh họa rõ hơn</p><pre><code class="language-python">class FileWriter:
    def write():
        #TODO: write string data to text file

class Client:
    def __init__(self, writer):
        self.writer = writer

    def program():
        # get data from somewhere
        self.writer.write(data);

file_writer = FileWriter()
client = Client(file_writer)
client.program()
</code></pre><p>Qua đoạn code trên ta có thể thấy rõ việc ngôn ngữ sử dụng duck-typing không hề quan tâm đến type của <code>writer</code> là gì, nó sẽ cố gắng tìm xem <code>writer</code> object được truyền vào có hiện thực method <code>write</code> hay không và tiến hành gọi hàm. Nghe tới đây thì ta có thể nhận ra rằng Python nói riêng và các ngôn ngữ kiểu động có thể dễ dàng giải quyết vấn đề mà các ngôn ngữ kiểu tĩnh như Java ở phần trước đã gặp phải ngay trong code. Quay lại requirement được thêm vào ở phần trên, ta cần thêm chức năng ghi ra file <code>.proto</code>, với python ta chỉ cần dễ dàng thêm (import) thư viện mà ta muốn dùng để ghi file <code>.proto</code> và truyền nó vào constructor của <code>Client</code> khi cần sử dụng.</p><pre><code class="language-python">class ProtoFileWriter:
    def write():
        #TODO: write string data to .proto file

# handle for .proto file writing
proto_file_writer = ProtoFileWriter()
client = Client(proto_file_writer)
client.program()
</code></pre><p>Nhưng không có gì là hoàn hảo, vấn đề của duck typing chính là type safeguard, vì nó không quan tâm đến kiểu của object mà thay vào đó là cố gắng đi tìm xem method đó có được hiện thực bởi object cho trước tại thời điểm runtime dẫn đén trường hợp một object gọi một method không được định nghĩa cùng với kiểu của nó sẽ dẫn tới bug. Cùng với ví dụ trên, giả sử một anh lập trình viên nào đó cũng tìm được một thư viện khác hỗ trợ việc ghi ra file proto nhưng lại không đọc kỹ docs hay vì một lý do nào đó không biết hàm mà thư viện đó cung cấp tên là <code>write_to_proto</code> chẳng hạn thay vì <code>wirte</code> nên dẫn đến chương trình bị lỗi. Điều này rất nguy hiểm vì chúng ta không có cách nào nhận ra dễ dàng tại thời điểm compile vì nó chỉ xảy ra tại thời điểm runtime, chưa kể nếu những đoạn code này không được test một cách kỹ càng thì thật sự nó sẽ thành thảm họa.</p><pre><code class="language-python">class OtherProtoFileWriter:
    def write_to_proto():
        #TODO: write string data to .proto file
        
# handle for .proto file writing
proto_file_writer = OtherProtoFileWriter()
client = Client(proto_file_writer)
client.program() # &lt;-- crashed here at runtime
</code></pre><h2>2. Go Interface</h2><p>Trong phần trước chúng ta đã có cái nhìn tổng thể về sự hiện diện của interface trong các ngôn ngữ lập trình như thế nào. Go cũng không phải là một ngoại lệ, vì Go được ra đời sau nên nó thừa kế được những điểm mạnh của các ngôn ngữ đi trước. Go chấp nhận cả hai tư tưởng ở trên vì rõ ràng các trường hợp đó xuất hiện hằng ngày trong lúc chúng ta lập trình. Vậy Go đã đưa ra giải pháp thế nào cho việc tận dụng điểm mạnh của cả hai ? Và đó là lúc implicit interface xuất hiện</p><h3>2.1 Go Interface là Implicit Interface và là Type-Safe Duck Typing</h3><p>Trước khi đào sâu vào các khía cạnh của interface trong Go, mình sẽ một lần nữa hiện thực lại ví dụ ở phần trước bằng Go code để có thể làm rõ được các vấn đề mà chúng ta đã nêu từ đầu bài viết</p><pre><code class="language-go">type Writer interface {
    write(data string)
}

type FileWriter struct {}

func (f *FileWriter) write(data string) {
    // write string data to text file
}

type Client struct {
    writer Writer
}

func (c *Client) program() {
    // get data from somewhere
    c.writer.write(data)
}

func main() {
    fileWriter := FileWriter{}
    client := Client{writer: &amp;fileWriter}
    client.program()
}
</code></pre><p>Nhìn thoáng qua phần hiện thực ở trên có ý tưởng gần giống Java, nhưng có một điểm khác biệt quan trọng là có vẻ <code>FileWriter</code> chính là kiểu đang hiện thực <code>Writer</code> interface nhưng lại không hề có sự xuất hiện của keyword <strong><code>implements</code></strong> . Và chính xác <code>FileWriter</code> đang hiện thực <code>Writer</code> interface như mọi người nghĩ, điều này nói lên Interface trong Go là <strong>Implicit Interface</strong> tức là một kiểu rời rạc (concrete type - theo cách gọi của Go) khi hiện thực bất kỳ interface nào thì không cần chỉ ra cụ thể interface mà nó hiện thực. Chính vì thế một concrete type T được xem như đang hiện thực một interface I chỉ cần thỏa điều kiện là T đang sở hữu các hàm (implementation) mà I đã định nghĩa mà không cần biết đến sự có mặt của I.</p><p><em>Khi cần thêm một writer mới</em></p><pre><code class="language-go">type ProtoFileWriter struct {}

func (f *ProtoFileWriter) write(data string) {
    // write string data to .proto file
}

func main() {
    fileWriter := FileWriter{}
    client := Client{writer: &amp;fileWriter}
    client.program()

    // for .proto file
    protoFileWriter := ProtoFileWriter{}
    client = Client{writer: &amp;protoFileWriter} 
    client.program()
}
</code></pre><p>Quay lại đoạn code ở trên, nếu ta bỏ qua phần định nghĩa interface <code>Writer</code> thì ta có thể thấy phần còn lại rất giống phần ví dụ bằng code Python ở phần trước. Cách triển khai đang thể hiện rất rõ ý tưởng của Duck Typing nhưng lại có một ưu điểm so với cách dùng ở các ngôn ngữ kiểu động nằm ở việc đảm bảo <code>writer</code> được truyền vào <code>Client</code> vẫn thuộc interface <code>Writer</code>, điều mà Python hay các ngôn ngữ kiểu động không làm được ở thời điểm compile. Đó là lý do tại sao Interface của Go cũng có thể được xem là <strong>Type-Safe Duck Typing</strong>, người sử dụng sẽ luôn biết chính xác mình đang có trong tay những thứ mình thật sự mong muốn như cách mà các ngôn ngữ kiểu tĩnh hoạt động thay vì là sự mơ hồ ở các ngôn ngữ kiểu động.</p><p><em>Khi kiểu không thuộc interface type sẽ báo lỗi tại thời điểm complie</em></p><pre><code class="language-go">type OtherProtoFileWriter struct {}

func (f *OtherProtoFileWriter) writeToProto(data string) {
    // write string data to .proto file
}

func main() {
    fileWriter := FileWriter{}
    client := Client{writer: &amp;fileWriter}
    client.program()

    protoFileWriter := OtherProtoFileWriter{}
    // Error: Cannot use '&amp;protoFileWriter' (type *OtherProtoFileWriter) as 
    // the type Writer Type does not implement 'Writer' as some 
    // methods are missing: write(data string)
    client = Client{writer: &amp;protoFileWriter} 
    client.program()
}
</code></pre><h3>2.2 Interface dưới góc nhìn của Go</h3><p>Ở phần trước mình đã làm rõ tại sao Go Interface lại được xem như là một <strong>Implicit Interface</strong> hay <strong>Type-Safe Duck Typing</strong> nhưng chưa có một định nghĩa rõ ràng, nên trong phần mình sẽ nói sâu thêm về Interface dưới góc nhìn của chính nó (Go).</p><ul><li><strong>Go Interface hay Interface type được định nghĩa là một tập hợp của các methods mà các kiểu rời rạc (concrete type) phải hiện thực để được xem như là một instance của interface đó.</strong></li><li>Interface trong Go là abstract type duy nhất.</li><li>Các kiểu thỏa mãn interface (Interface Statisfaction) nếu chúng sở hữu các methods mà interface đó yêu cầu mà không cần đặc tả interface đó.</li></ul><p>Chính vì tính flexible của Go Interface nên Go được xem như một ngôn ngữ dễ mở rộng nhưng cũng dễ maintaint vì vẫn giữ được sự mạnh mẽ của hệ thống type ở ngôn ngữ kiểu tĩnh. Ngoài ra, một điểm mạnh khác cũng giúp phát huy sức mạnh của Go chính là các standard libs mà đội ngũ các kỹ sư tại Google cung cấp. Các thư viện này được xây dựng dựa trên các Interface đã được chuẩn hóa rất tốt và được xem như nền tảng của bất kỳ lĩnh vực nào nó góp mặt. Nó khuyến khích các lập trình viên tận dụng sức mạnh của chúng để xây dựng và mở rộng các thư viện có liên quan. Nên nếu các bạn đọc qua nhiều open source được viết bằng Go, lúc nào ta cũng thấy sự xuất hiện của các Interface đến từ standard libs, điều này giúp cho ngôn ngữ trở nên thống nhất nhưng tính linh hoạt lại rất cao. Đó cũng là lý do ta có thể khó kiếm được một canonicial framework nào ở Go như ở các ngôn ngữ khác như Ruby's Rails, Python's Django, Java's Spring vì những thứ mà Go cung cấp là đủ dùng, mặc dù là không thiếu những framework với mục đích như vậy nhưng chúng cũng đều được build dựa trên các interface của thư viện chuẩn nên trong trường hợp cần ta chỉ cần gắn kết những thứ mà ta thật sự cần. Trong những bài viết sau mình sẽ đào sâu hơn vào các interface như vậy, một trong số đó là <code>http.Handler</code>, interface kinh điển mà bất kỳ lập trình viên nào khi lập trình web với Go đều phải biết.</p><h2>Kết</h2><p>Trong bài này mình đã giới thiệu sơ lược về Go Interface và đặc tính quan trọng của nó thông qua góc nhìn từ các ngôn ngữ khác. Mình chưa làm việc với Java, nhưng qua bài này mình đã hiểu thêm về Java nhưng chắc không thể không có thiếu xót nên mong nhận được thêm ý kiến và góp ý về vấn đề này. Bài khá dài, viết cũng mất rất nhiều thời gian vì mình phải đọc thêm rất nhiều tài liệu liên quan, nhưng sau khi viết xong mình càng hiểu rõ, hiểu sâu hơn và có cái nhìn rộng bao quát hơn về chủ đề này. Hy vọng bài này giúp mọi người có góc nhìn rõ hơn về Go Interface nhé!</p><h3>Read more</h3><p><a href="https://www.amazon.com/Learning-Go-Idiomatic-Real-World-Programming/dp/1492077216#:~:text=Networking%20%26%20Cloud%20Computing-,Learning%20Go%3A%20An%20Idiomatic%20Approach%20to%20Real%2DWorld%20Go%20Programming,-1st%20Edition">Learning Go: An Idiomatic Approach to Real-World Go Programming</a></p><p><a href="https://www.amazon.com/Programming-Language-Addison-Wesley-Professional-Computing/dp/0134190440">Go Programming Language, The (Addison-Wesley Professional Computing Series)</a></p><p><a href="https://en.wikipedia.org/wiki/Duck_typing">Duck Typing</a></p><p><a href="https://en.wikipedia.org/wiki/SOLID">SOLID - Dependency inversion principle</a></p>]]></content:encoded></item><item><guid isPermaLink="true">https://hung-m-dao.github.io/thao/cap</guid><title>CAP Theorem</title><description>Khi thiết kế hệ thống phân tán (distributed system) có một định lý nền tảng quan trọng đó là CAP theorem. Trong bài viết này chúng ta cùng tìm hiểu về các khía cạnh này của định lý này.</description><link>https://hung-m-dao.github.io/thao/cap</link><pubDate>Wed, 23 Mar 2022 16:55:00 +0000</pubDate><content:encoded><![CDATA[<h1>CAP Theorem</h1><p>Khi nhắc tới các hệ thống phân tán (distributed system) có một định lý nền tảng quan trọng đó là “CAP theorem"</p><h2>1 WHAT - CAP theorem là gì ?</h2><p>Định lý CAP nói rằng (ở đây xin trích dẫn nguyên văn tiếng Anh)</p><blockquote>
It is impossible for a web service to provide the following three guarantees:<br>
- Consistency <br>
- Availability <br>
- Partition-tolerance <br>
</blockquote><p>Những thuộc tính trên: consistency, availability, partition-tolerance là những yếu tố mà khi xây dựng một hệ thống phần mềm thực tế đều hướng đến. Vậy trước tiên ta cần hiểu rõ các khái niệm này.</p><h3>1.1 Consistency</h3><p>Consistency ở đây nói đến việc khi một request được gửi tới một hệ tống phân tán thì nó phải được phản hồi ngay lập tức bởi một giá trị nào đó. Và quan trọng hơn là kết quả khi thực một request để đọc dữ liệu ngay sau khi kết thúc việc ghi dữ liệu phải đảm bảo việc lấy ra dữ liệu vừa được ghi thay vì các dữ liệu trước đó (stale data). Hay hiểu đơn giản trong một hệ thống database gồm n nodes, thì sau khi hoàn tất việc ghi dữ liệu ở bất kỳ node nào, thì việc đọc dữ liệu ở tất cả các node đều cho ra một kết quả giống nhau và là chính là dữ liệu được ghi thành công sau cùng.</p><h3>1.2 Availability</h3><p>Tính khả dụng định nghĩa rằng với bất kỳ request nào được nhận bởi một node đang hoạt động trong hệ thống phải trả về một response tương ứng, điều đó có nghĩa tất cả mọi giải thuật và process bên trọng đều phải kết thúc vào một thời điểm nào đó (eventually terminate) cho dù gặp phải vấn đề gì.</p><h3>1.3 Partition-tolerance</h3><p>Thuộc tính này là điều kiện đảm bảo cho hai đăc tính trên trong hệ thống phân tán. Partition-tolerance nói rằng khi có một phần hệ thống bị sập thì hệ thống vẫn có thể trả về kết quả cho một request tương ứng. Điều cho phép việc các message được truyền tải giữa các phần (các nodes) có thể bị mất (lost) hoặc bị trì hoàn (delayed)</p><h3>Read more</h3><ul><li><a href="https://awoc.wolski.fi/dlib/big-data/GiLy02-CAP.pdf">Brewer’s Conjecture and the Feasibility of Consistent, Available, Partition-Tolerant Web Services</a></li></ul>]]></content:encoded></item><item><guid isPermaLink="true">https://hung-m-dao.github.io/hung/dunning-kruger</guid><title>Dunning-Kruger effect</title><description>"You're not as smart as you think you are"</description><link>https://hung-m-dao.github.io/hung/dunning-kruger</link><pubDate>Wed, 23 Mar 2022 10:55:00 +0000</pubDate><content:encoded><![CDATA[<h1>Dunning-Kruger effect</h1><p>The <strong>Dunning-Kruger effect</strong> is a type of cognitive bias in which people believe that they are smarter and more capable than they really are. Essentially, low ability people do not possess the skills needed to recognize their own incompetence.</p><img src="https://hung-m-dao.github.io//images/dunning-kruger.jpeg" alt="Dunning-Kruger chart"/>]]></content:encoded></item></channel></rss>