<?xml version="1.0" encoding="UTF-8"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/"><channel><title>My blog</title><description>Hello! I'm Hung, and this is my personal space.</description><link>https://hung-m-dao.github.io/</link><language>en</language><lastBuildDate>Fri, 25 Mar 2022 05:18:09 +0000</lastBuildDate><pubDate>Fri, 25 Mar 2022 05:18:09 +0000</pubDate><ttl>250</ttl><atom:link href="https://hung-m-dao.github.io/feed.rss" rel="self" type="application/rss+xml"/><item><guid isPermaLink="true">https://hung-m-dao.github.io/hung/md-to-html</guid><title>Làm Blog bằng Publish - Xuất HTML từ file Markdown</title><description>Thay vì ngủ lúc 10h thì mình đã thức đến 1h để làm gì ?</description><link>https://hung-m-dao.github.io/hung/md-to-html</link><pubDate>Fri, 25 Mar 2022 11:55:00 +0000</pubDate><content:encoded><![CDATA[<h1>Làm Blog bằng Publish - Xuất HTML từ file Markdown</h1><p>Mình viết blog này bằng <a href="https://github.com/JohnSundell/Publish">Publish</a>, nó là một công cụ giúp tạo ra những trang web tĩnh, dành cho những lập trình viên sử dụng Swift. Chi tiết hơn về Publish sẽ được trình bày trong bài viết khác, bài viết này sẽ nói về hành trình mình tìm giải pháp xuất HTML của mình.</p><h3>Tại sao phải xuất HTML ?</h3><p>Publish vốn có thể tự động parse file Markdown thành HTML, thông qua <a href="https://github.com/JohnSundell/Ink">Ink</a> - một công cụ cũng do tác giả của Publish viết. Tuy nhiên, công cụ này còn rất nhiều thiếu sót (chính tác giả cũng nói vậy), và có rất nhiều tính năng của Markdown không parse được thành HTML (nested block, list in block,... ). Do đó mình bắt đầu đi tìm giải pháp tốt hơn để tạo ra file HTML (vì Publish cũng support raw HTML).</p><h3>Typora</h3><p>Sau khi tham khảo nhiều Markdown editor thì mình quyết định bắt đầu với <a href="https://typora.io/">Typora</a>, một công cụ được recommend rất nhiều. Typora có rất nhiều ưu điểm, như giao diện tối giản, xuất được rất nhiều định dạng file, đặc biệt có thể xuất HTML without styles - thứ mình rất cần.</p><p>Tuy nhiên, vì những nhược điểm sau, mà mình đã không chọn Typora:</p><ul>
<li>Tốn phí, $15.</li>
<li>Mình cần side panel để preview, nhưng không có option này.</li>
<li>Kiểu edit WYSIWYG làm mình khó chịu, loay hoay 2 phút cũng không xóa được 1 code block.</li>
</ul><h3>Quay đầu là bờ</h3><p>Loay hoay thêm 1 lúc với nhiều Markdown editor khác nhưng vẫn không ưng, mình nhớ ra VSCode và quyết định thử với nó. VSCode đã có sẵn rất nhiều thứ mình cần: Vim keybindings, side panel preview, theme/font configurations... . Nhưng có một thứ rất quan trọng mà VSCode đang thiếu: xuất HTML without styles.</p><p>Mình có thử google và thấy <a href="https://code.visualstudio.com/docs/languages/markdown#_compiling-markdown-into-html">hướng dẫn</a> của chính VSCode, nhưng có vẻ hơi phức tạp nên mình để lại thử sau. Sau khi thử với nhiều Markdown extension khác nhau, mình vẫn không có được kết quả như ý, vì cùng 1 lí do: những extension này không có option xuất HTML <strong>without styles</strong>. Mình đành quay lại đọc hướng dẫn &quot;chính chủ&quot;.</p><h3>markdown-it</h3><p>Đọc hướng dẫn của VSCode thì mình thấy họ dùng command <a href="https://github.com/markdown-it/markdown-it">markdown-it</a> để làm ví dụ. Mình có vào xem github thì thấy đây là một thư viện của NodeJs, có kèm theo CLI, và rất dễ sử dụng. Mình mừng như cá gặp nước và nhanh chóng bắt tay vào setup.</p><p>Sau vài sự tìm kiếm thì extension mình đã dùng là <a href="https://marketplace.visualstudio.com/items?itemName=edonet.vscode-command-runner">Command Runner</a>, nó cho phép mình bind shortcut key đến một command đã được định nghĩa trước. Đây là đoạn config mình dùng để định nghĩa command, được thêm vào file <code>settings.json</code> của VSCode:</p><pre><code class="language-json"> &quot;command-runner.terminal.name&quot;: &quot;runCommand&quot;,
    &quot;command-runner.terminal.autoClear&quot;: true,
    &quot;command-runner.terminal.autoFocus&quot;: true,
    &quot;command-runner.commands&quot;: {
        &quot;Export Markdown to HTML&quot;: &quot;cd ${fileDirname} &amp;&amp; markdown-it ${fileBasename} -o ${fileBasenameNoExtension}.html&quot;,
    },
</code></pre><p>Và để bind với shortcut thì mình đã thêm vào <code>keybindings.json</code>:</p><pre><code class="language-json">[
    {
        &quot;key&quot;: &quot;ctrl+cmd+e&quot;,
        &quot;command&quot;: &quot;command-runner.run&quot;,
        &quot;args&quot;: {
            &quot;command&quot;: &quot;Export Markdown to HTML&quot;,
            &quot;terminal&quot;: &quot;runCommand&quot;
        }
    }
]
</code></pre><p>Như vậy, mỗi lần soạn xong file Markdown, thì mình chỉ cần nhấn Ctrl+Cmd+E thì sẽ có một file HTML cùng tên được xuất ra ở cùng thư mục.</p><h3>30 chưa phải là Tết</h3><p>Tưởng chừng đã giải quyết được vấn đề và có thể đi ngủ, nhưng đời không như là mơ. Khi test thử với vài sample file thì mình đã phát hiện, <code>markdown-it</code> chưa hỗ trợ một số tính năng của Markdown, như foot-note, subscript, supscript,... . Sau khi quay lại xem document của họ, thì mình mới biết là cần dùng thêm <a href="https://github.com/markdown-it/markdown-it#syntax-extensions">syntax extensions</a> để dùng được những tính năng đó. Tuy nhiên không hề có hướng dẫn nào để load plugin cho CLI, mình tìm rất nhiều nhưng đều không có kết quả. Tới đây thì đã khá tuyệt vọng và buồn ngủ, mình đành tìm file binary của command đó xem source, hi vọng cuối. Để tìm &quot;nguồn gốc&quot; của <code>markdown-it</code>, mình dùng command:</p><pre><code class="language-bash">$ type -a markdown-it
</code></pre><p>và nhận được output <code>/usr/local/bin/markdown-it</code></p><p>Mình tìm đến directory trên và mở file binary lên, thật may là syntax dường như của JS, mình đã có thể load thêm plugin mà mình cần.</p><pre><code class="language-javascript">  md = require('..')({
    html: !options.no_html,
    xhtmlOut: false,
    typographer: options.typographer,
    linkify: options.linkify
  }).use(require('markdown-it-footnote'))
    .use(require('markdown-it-sub'))
    .use(require('markdown-it-sup'));
</code></pre><p>Voilà! Cuối cùng cũng đi ngủ được rồi.</p><h3>Kết</h3><p>Mặc dù có thể mình đã mắc phải <a href="https://en.wikipedia.org/wiki/XY_problem">XY Problem</a> khi cố đi tìm cách xuất file HTML, nhưng hành trình đi tìm giải pháp đã giúp mình học thêm và phát hiện được thêm khá nhiều thứ. Worth the effort ^^.</p>]]></content:encoded></item><item><guid isPermaLink="true">https://hung-m-dao.github.io/hung/collectors-fallacy</guid><title>Collector's fallacy</title><description>The reason why I bought 100+ games on Steam but only play ~5 of them.</description><link>https://hung-m-dao.github.io/hung/collectors-fallacy</link><pubDate>Fri, 25 Mar 2022 00:15:00 +0000</pubDate><content:encoded><![CDATA[<h1>Collector's fallacy</h1><h2>What is it ?</h2><p><strong>Collector’s Fallacy</strong><sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup> is the urge to collect something that you never use or need, but the act of collecting gives you a good feeling.
The sciene behind this, is,  each time we discover a new productivity toy, our brain sends us a jolt of <a href="https://en.wikipedia.org/wiki/Dopamine">dopamine</a> (our brain’s “reward” hormone)</p><h2>How to avoid it</h2><ul>
<li>&quot;Own&quot; before you collect</li>
</ul><p>Think it through before making any decision, take it slow.</p><ul>
<li>Purging</li>
</ul><p>Get rid of things you don't really touch. My rule of thumb: If you haven't used it in a year, throw it away.</p><ul>
<li>Measuring</li>
</ul><p>Always keep track of what you already have, remind yourself of the old items, this might help reduce the need of collecting new stuffs.</p><hr class="footnotes-sep">
<section class="footnotes">
<ol class="footnotes-list">
<li id="fn1" class="footnote-item"><p><em><a href="https://observer.com/2017/05/the-collectors-fallacy-why-we-gather-things-we-dont-need/">The Collector’s Fallacy: Why We Gather Things We Don’t Need</a></em> <a href="#fnref1" class="footnote-backref">↩︎</a></p>
</li>
</ol>
</section>
]]></content:encoded></item><item><guid isPermaLink="true">https://hung-m-dao.github.io/thao/cap</guid><title>CAP Theorem</title><description>Khi thiết kế hệ thống phân tán (distributed system) có một định lý nền tảng quan trọng đó là CAP theorem. Trong bài viết này chúng ta cùng tìm hiểu về các khía cạnh này của định lý này.</description><link>https://hung-m-dao.github.io/thao/cap</link><pubDate>Wed, 23 Mar 2022 16:55:00 +0000</pubDate><content:encoded><![CDATA[<h1>CAP Theorem</h1><p>Khi nhắc tới các hệ thống phân tán (distributed system) có một định lý nền tảng quan trọng đó là “CAP theorem"</p><h2>1 WHAT - CAP theorem là gì ?</h2><p>Định lý CAP nói rằng (ở đây xin trích dẫn nguyên văn tiếng Anh)</p><blockquote>
It is impossible for a web service to provide the following three guarantees:<br>
- Consistency <br>
- Availability <br>
- Partition-tolerance <br>
</blockquote><p>Những thuộc tính trên: consistency, availability, partition-tolerance là những yếu tố mà khi xây dựng một hệ thống phần mềm thực tế đều hướng đến. Vậy trước tiên ta cần hiểu rõ các khái niệm này.</p><h3>1.1 Consistency</h3><p>Consistency ở đây nói đến việc khi một request được gửi tới một hệ tống phân tán thì nó phải được phản hồi ngay lập tức bởi một giá trị nào đó. Và quan trọng hơn là kết quả khi thực một request để đọc dữ liệu ngay sau khi kết thúc việc ghi dữ liệu phải đảm bảo việc lấy ra dữ liệu vừa được ghi thay vì các dữ liệu trước đó (stale data). Hay hiểu đơn giản trong một hệ thống database gồm n nodes, thì sau khi hoàn tất việc ghi dữ liệu ở bất kỳ node nào, thì việc đọc dữ liệu ở tất cả các node đều cho ra một kết quả giống nhau và là chính là dữ liệu được ghi thành công sau cùng.</p><h3>1.2 Availability</h3><p>Tính khả dụng định nghĩa rằng với bất kỳ request nào được nhận bởi một node đang hoạt động trong hệ thống phải trả về một response tương ứng, điều đó có nghĩa tất cả mọi giải thuật và process bên trọng đều phải kết thúc vào một thời điểm nào đó (eventually terminate) cho dù gặp phải vấn đề gì.</p><h3>1.3 Partition-tolerance</h3><p>Thuộc tính này là điều kiện đảm bảo cho hai đăc tính trên trong hệ thống phân tán. Partition-tolerance nói rằng khi có một phần hệ thống bị sập thì hệ thống vẫn có thể trả về kết quả cho một request tương ứng. Điều cho phép việc các message được truyền tải giữa các phần (các nodes) có thể bị mất (lost) hoặc bị trì hoàn (delayed)</p><h3>Read more</h3><ul><li><a href="https://awoc.wolski.fi/dlib/big-data/GiLy02-CAP.pdf">Brewer’s Conjecture and the Feasibility of Consistent, Available, Partition-Tolerant Web Services</a></li></ul>]]></content:encoded></item><item><guid isPermaLink="true">https://hung-m-dao.github.io/hung/dunning-kruger</guid><title>Dunning-Kruger effect</title><description>"You're not as smart as you think you are"</description><link>https://hung-m-dao.github.io/hung/dunning-kruger</link><pubDate>Wed, 23 Mar 2022 10:55:00 +0000</pubDate><content:encoded><![CDATA[<h1>Dunning-Kruger effect</h1><p>The <strong>Dunning-Kruger effect</strong> is a type of cognitive bias in which people believe that they are smarter and more capable than they really are. Essentially, low ability people do not possess the skills needed to recognize their own incompetence.</p><img src="https://hung-m-dao.github.io//images/dunning-kruger.jpeg" alt="Dunning-Kruger chart"/>]]></content:encoded></item></channel></rss>