<?xml version="1.0" encoding="UTF-8"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/"><channel><title>My blog</title><description>Hello! I'm Hung, and this is my personal space.</description><link>https://hung-m-dao.github.io/</link><language>en</language><lastBuildDate>Tue, 5 Apr 2022 16:21:02 +0000</lastBuildDate><pubDate>Tue, 5 Apr 2022 16:21:02 +0000</pubDate><ttl>250</ttl><atom:link href="https://hung-m-dao.github.io/feed.rss" rel="self" type="application/rss+xml"/><item><guid isPermaLink="true">https://hung-m-dao.github.io/thao/go-select</guid><title>Go Concurrency - Select Statement</title><description>Go Concurrency - Select statement</description><link>https://hung-m-dao.github.io/thao/go-select</link><pubDate>Tue, 5 Apr 2022 14:55:00 +0000</pubDate><content:encoded><![CDATA[<h1>Go Concurrency - Select Statement</h1><p>Câu lệnh <code>select</code> trong Go có thể được xem là một trong những câu lệnh quan trọng mà Gopher cần phải nắm rõ khi làm việc với concurrency programing. Nó được xem như chất kết dính gắn kết các channel lại với nhau, đồng thời từ đó kiểm soát và giải quyết những vấn đề phổ biến trong mô hình concurrency của Go.</p><h2>1. Select statement là gì ? (WHAT)</h2><p>Câu lệnh select là một control structure dùng để lựa chọn hoạt động tại một thời điểm nhất định trong một tập các hoạt động "gửi (send)" và "nhận (recieve)" có thể xảy ra, để từ đó tiếp tục thực hiện các công việc kế tiếp dựa trên hoạt động được chọn. Về mặt cấu trúc thì <code>select statement</code> gần tương tự như <code>switch statement</code> (mọi người có thể tham khảo thêm specification của <code>select statement</code> <a href="https://go.dev/ref/spec#Select_statements">tại đây</a>)</p><pre><code class="language-go">var c1, c2 &lt;-chan interface{}
var c3 chan&lt;- interface{}

select {
case &lt;- c1:
 // Do something
case s := &lt;- c2:
 // Do something with s
case c3 &lt;- struct{}{}:
 // Do something
}
</code></pre><h2>2. Tại sao cần select ? (WHY)</h2><p>Để hiểu lý do ta cùng xem xét ví dụ sau đây</p><pre><code class="language-go">const TARGET_COUNT = //fill this
func wait() {
	time.Sleep(time.Duration(rand.Intn(30) + 1) * time.Millisecond)
}

func main() {
	chan1 := make(chan int)
	chan2 := make(chan int)
	var count1, count2 int
	go func(ch chan int) {
		for {
			wait()
			ch &lt;- 1
			count1++
			if count1 == TARGET_COUNT {
				close(ch)
				break
			}
		}
	}(chan1)

	go func(ch chan int) {
		for {
			wait()
			ch &lt;- 2
			count2++
			if count2 == TARGET_COUNT {
				close(ch)
				break
			}
		}
	}(chan2)

    // without select
	for {
		&lt;-chan1
		&lt;-chan2
		if count1 == TARGET_COUNT || count2 == TARGET_COUNT {
			break
		}
	}

	fmt.Println(count1, count2)

}
</code></pre><p>Trong ví dụ trên minh đã sử dụng hàm <code>main</code> một web server đang gọi request tới 2 service khác nhau trong hệ thống để lấy data bằng việc sử dụng 2 Goroutine và 2 unbuffered channel tương ứng. Do để giống với request thật nên mình đã dùng hàm <code>wait()</code> tương ứng với việc mỗi request cần tốn thời gian để xử lý I/O mà ở đây thời gian sẽ được random với mỗi requets trong khoảng từ 1 đến 30 miliseconds. Chương trình sẽ kết thúc khi tất cả request (được đặc tả bằng <code>TARGET_COUNT</code>) được cả hai Gorountine handle xong, một điều quan trọng trong ví dụ trên mình không dùng <code>select</code> để handle việc đọc dữ liệu ở các channel. Vậy nếu dùng select thì nó sẽ ra sao ?</p><pre><code class="language-go">// with select
	for {
		if count1 == TARGET_COUNT &amp;&amp; count2 == TARGET_COUNT {
			break
		}
		select {
		case &lt;-chan1:
		case &lt;-chan2:
		}
	}
</code></pre><p>Và sau khi chạy chương trình trên thì ta được thời gian thực thi tương ứng cho việc không dùng và có dùng <code>select</code> như sau</p><pre><code class="language-shell">Req(TARGET_COUNT)   with_select     without_select 
10000 			    2m39.559101617s	3m4.613266231s 
10000			    2m39.482978441s	3m4.713822436s	
20000               5m19.559837128s 6m10.476351502s
20000               5m19.615773995s 6m10.342784533s
30000               8m1.715319027s  9m17.175114517s
30000               8m1.257952793s  9m17.100923682s
</code></pre><p>Ở đây mình cho chương handle số lượng request lầ lượt là 10000, 20000, 30000 cho mỗi lần chạy và chạy 2 lần cho mỗi số lượng request để tránh sai số . Kết quả ở trên được chạy trên máy tính linux với CPU Intel® Core™ i5-6500 CPU @ 3.20GHz × 4, nên lưu ý kết quả khi chạy ở các thiết bị với vi xử lý khác có thể sẽ có kết quả khác. Qua kết quả trên ta có thể thấy việc sử dụng select giúp cho việc xử lý request nhanh hơn hẳn với việc không sử dụng. Ở trên các bạn có thể thấy chỉ có 2 channel và thời gian I/O cũng chỉ là vài milisecond và số lượng request chỉ dừng lại ở mức chục ngàn, nhưng với các hệ thống thực tế thì chúng ta có thể cần dùng nhiều channel hơn, thời gian thực hiện I/O cho mỗi request kéo dài hơn và số lượng request là lớn hơn rất nhiều.</p><p>Nếu chúng ta nhìn kỹ ở phần không sử dụng <code>select</code> thì đoạn code đó không thực sự là <code>concurrency</code>, hai channel của chúng ta được đọc một cách tuần tự, mà như các bạn đã biết các channel chỉ có thể được đọc khi nó hoàn tất việc ghi dữ liệu tức là nó sẽ block Gorountine đang sở hữu nó cho tới khi có một hoạt động ghi vào channel đó. Nhìn vào đoạn code trên thì channel 1 luôn được ưu tiên để đọc trước, nên trong một số trường hợp khi thời gian I/O của Gorountine chứa channel 2 thấp hơn dẫn đến channel 2 đã ready để được xử lý nhưng chúng vẫn phải đợi đến khi Gorountine của channel 1 hoàn thành công việc. Đây chính là tình huống mà starvation đã xảy ra tại Goroutine chứa channel 2. Tương tự nếu chúng ta thay đổi thứ tự của cả 2 thì hiện tượng như vậy cũng sẽ xảy ra với Gorountine chứa channel 1. Đây cũng chính là lý do tại sao chúng ta cần sử dụng <code>select</code>.</p><p>Khi sử dụng <code>select</code> bất cứ khi nào một channel nào ready(sẵn sàng để ghi hoặc đọc) trong các channel đang tồn tại trong câu lệnh select, thì ngay lập tức nó sẽ được chọn để tiếp tục handle tiếp tục bởi <code>select</code>. Chính vì thế sẽ gần như sẽ không có idle time , resource cũng được tận dụng hết khả năng và đó mới thật sự là "Concurrency".</p><h2>2. Đào sâu thêm về select</h2><h3>2.1 Khi các channel đều sẵn sàng để ghi tại một thời điểm</h3><p>Để biểu diễn các channel sẵn sàng để ghi tại một thời điểm, chúng ta sẽ close channel ngay sau khi khởi tạo. Điều này tận dụng việc channel vẫn có thể được đọc và luôn sẵn sàng để đọc sau khi đóng như yêu cầu.</p><pre><code class="language-go">func main()
	c1 := make(chan interface{})
	close(c1)
	c2 := make(chan interface{})
	close(c2)
	c3 := make(chan interface{})
	close(c3)
	var c1Count, c2Count, c3count int
	for i := 3000; i &gt;= 0; i-- {
		select {
		case &lt;-c1:
			c1Count++
		case &lt;-c2:
			c2Count++
		case &lt;-c3:
			c3count++
		}
	}
	fmt.Printf("c1Count: %d\nc2Count: %d\nc3Count: %d\n", c1Count, c2Count, c3count)
</code></pre><p>Kêt quả sau khi thực thi chương trình trên</p><pre><code class="language-shell">c1Count: 978
c2Count: 999
c3Count: 1024
</code></pre><p>Kết quả cho thấy 3 biến count có giá trị gần bằng nhau, điều này cho thấy các hoạt động đọc dữ liệu từ channel khi sử dụng <code>select</code> được lựa chọn một cách bình đẳng không có một case nào được ưu tiên hơn. Để làm được điều này Go đã sử dụng một thuật toán uniform pseudo-random để lựa chọn channel tại mỗi thời điểm thay vì chọn từ trên xuống như trong trường hợp của <code>switch case</code>. Nó giúp việc lựa chọn không bị lệch về bất kỳ một Goroutine nào để tránh xảy ra hiện tượng starvation.</p><h3>2.2 Khi tất cả các channel không bao giờ sẵn sàng</h3><p>Trong trường hợp tất cả các channel bị stuck vì một lý do nào đó chúng ta cần có cách để kết thúc việc chờ đợi, mà một cách quen thuộc chính là set một giá trị timeout, với <code>select</code> chúng ta sẽ hiện thực như sau</p><pre><code class="language-go">func main() {
    start := time.Now()
    var c &lt;-chan int
    select {
    case &lt;-c:
    case &lt;-time.After(1 * time.Second):
        fmt.Println("Timed out.")
    }
    fmt.Println("Elapsed time: ", time.Since(start))
}

Timed out.
Time elapsed:  1.001240483s
</code></pre><p><code>time.Afetr()</code> sẽ trả về một read channel sau một khoảng thời gian được truyền vào, ta sẽ dùng nó làm một nhánh lựa chọn trong <code>select</code> để đảm bảo việc timeout của các channel.</p><h3>2.3 Khi chúng ta muốn tận dụng thời gian mà tất cả các đều channel đang bận</h3><p>Đây là lúc <code>default</code> xuất hiện, gần giống với <code>switch</code>, <code>default</code> branch sẽ dược thực thi khi tất cả các channel bị block.</p><pre><code class="language-go">done := make(chan interface{})
go func() {
    // Do something with a long interval 
    close(done)
}
loop:
    for {
        select {
        case &lt;-done:
            break loop
        default:
            //Do something when all channel blocked
        }
        //or Do something here 
    }
</code></pre><h3>2.4 Một số lưu ý khác</h3><ul><li>Câu lệnh <code>select</code> cũng cho phép chúng ta gán giá trị tại từng case có chứa recieve statement bằng "short variable declaration" ví dụ <code>case s := &lt;-chan1</code>, lúc này giá trị được đọc từ <code>chan1</code> sẽ được gán cho biến <code>s</code></li><li>Ngoài ra chúng ta cũng được Go cung cấp cấp câu lệnh select rỗng <code>select{}</code>, nó đơn giản là block Gorountine tương ứng mãi mãi và chỉ kết thúc khi có sự can thiêp bên ngoài. Trong những bài viết kế tiếp về Concurrency trong Go, chúng ta sẽ cùng nhau tìm hiểu kỹ hơn về nó. ## 3. Kết Qua bài viết này mình đã giới thiệu những khái niệm và cách sử dụng cơ bản về câu lệnh <code>select</code> của Go, một trong những chất liệu quan trọng của mô hình Concurrency của Go</li></ul><h2>Read more</h2><p><a href="https://go.dev/ref/spec#Select_statements">Go Select Statement Specification</a> <a href="https://www.amazon.com/Learning-Go-Idiomatic-Real-World-Programming/dp/1492077216#:~:text=Networking%20%26%20Cloud%20Computing-,Learning%20Go%3A%20An%20Idiomatic%20Approach%20to%20Real%2DWorld%20Go%20Programming,-1st%20Edition">Learning Go: An Idiomatic Approach to Real-World Go Programming</a></p><p><a href="https://www.amazon.com/Programming-Language-Addison-Wesley-Professional-Computing/dp/0134190440">Go Programming Language, The (Addison-Wesley Professional Computing Series)</a></p><p><a href="https://www.amazon.com/Concurrency-Go-Tools-Techniques-Developers/dp/1491941197">Concurrency in Go: Tools and Techniques for Developers</a></p>]]></content:encoded></item><item><guid isPermaLink="true">https://hung-m-dao.github.io/thao/race-condition</guid><title>Race condition là gì ?</title><description>Concurrency Problems - Race condition</description><link>https://hung-m-dao.github.io/thao/race-condition</link><pubDate>Sat, 2 Apr 2022 17:35:00 +0000</pubDate><content:encoded><![CDATA[<h1>Race condition là gì ?</h1><h2>Định nghĩa</h2><p>Race condition là tình huống một hay nhiều thread cùng cố gắng thay đổi giá trị của một biến trong vùng nhớ chung (shared memory) tại cùng một thời điểm, kết quả của việc thực thi phụ thuộc vào thứ tự cụ thể mà việc truy cập diễn ra, và thứ tự truy cập đó ta không thể kiểm soát. Điều này có thể dẫn đến kết quả không mong muốn của toàn bộ quá trình.</p><h2>Ví dụ</h2><p>Để hiểu rõ về vấn đề này mình đã viết một chương trình minh họa race condition bằng Go, mình sẽ dùng một khái niệm gần tương tự thread ở level OS để minh họa đó là <a href="https://go.dev/tour/concurrency/1">Gorountine</a> - lightweight thread được cung cấp bởi Go. Trong ví dụ này chúng ta sẽ mô phỏng việc "Thêm vào giả hàng" ở các trang thương mại điện tử, giả sử có một mặt hàng X hiện đang còn 1000 sản phẩm trong kho, tại thời điểm mở bán, 1000 khách hàng đồng thời thêm sản phẩm đó vào giỏ hàng. Sau đó ta sẽ kiểm tra xem liệu số lượng tồn kho sau khi 1000 khách hàng đã thêm vào giỏ có đúng bằng 0 theo đúng lý thuyết. Chúng ta sẽ mô phỏng 1000 request thêm vào giỏ hàng bằng việc tạo ra 1000 Gorountines và nhiệm vụ của mỗi Goroutine là giảm số lượng <code>stock</code> đi 1 đơn vị, <code>stock</code> ở đây sẽ global variable và được sử dụng chung bởi tất cả Gorountine như điều kiện đã đặt ra.</p><h3>Tiến hành</h3><pre><code class="language-go">var stock int = 1000

func add_to_cart(w *sync.WaitGroup) {
	defer w.Done()
	stock--
}

func main() {
	var w sync.WaitGroup
    w.Add(1000)
	for i := 0; i &lt; 1000; i++ {
		go add_to_cart(&amp;w)
	}
	w.Wait()
	fmt.Println("Current stock: ", stock)
}

</code></pre><p>Trong đoạn code trên mình có sử dụng một số utilities của <code>sync</code> package để giúp cho việc mô phỏng diễn ra chính xác. Vì hàm main (entry point của bất kỳ application nào trong Go) cũng là một Gorountine và một khi nó kết thúc thì tất cả các Gorountine khác cũng bị drop nên <code>w.Wait()</code> xuất hiện ở đây đề giúp cho <code>main</code> chờ các Gorountine khác kết thúc trước khi nó kết thúc. <code>w.Add()</code> được gọi trong main Goroutine để thêm vào số lượng Goroutine mà nó cần chờ, ở đây là 1000 Goroutines. Sau khi hoàn thành công việc thì Goroutine sẽ signal cho main Gorountine bằng việc gọi hàm <code>w.Done()</code> mà ta có thể thấy trong <code>add_to_cart</code> qua câu lệnh <code>defer w.Done()</code>, <a href="https://go.dev/tour/flowcontrol/12">defer</a> là một keyword trong Go dùng để nói với hàm sở hữu nó thực hiện câu lệnh ngay sau keyword <code>defer</code> tại thời điểm kết thúc.</p><h3>Kết quả và giải thích</h3><pre><code class="language-shell">Current stock:  93
Current stock:  32
Current stock:  114
Current stock:  22
Current stock:  6
</code></pre><p>Sau khi tiến hành thực thi chương trình ở trên 5 lần chúng ta nhận được 5 kết quả khác nhau và không có kết quả nào đúng như kết quả mà ta mong muốn là số lượng stock còn lại là 0. Vậy tại sao kết quả lại như vậy ?</p><p>Trong phần định nghĩa có nói kết quả của quá trình thực thi sẽ phụ thuộc vào thứ tự mà việc truy cập vào vùng nhớ chung diễn ra. Ta cần biết rằng các Gorountine sẽ được thực thi theo một thứ tự mà ta không thể kiểm soát, mà nó được quyết định bởi runtime scheduler của Go cũng tương tư thread ở level OS sẽ được quyết định bởi OS scheduler. Việc này dẫn tới tại một thời điểm các Goruntine được thực thi cùng lúc với nhau dẫn đến việc biến <code>stock</code> được truy cập cùng lúc. Đây cũng là nguyên nhân dẫn tới việc biến <code>stock</code> bị tính toán sai mà ở đây một cách chi tiết là qua câu lệnh <code>stock--</code>. Vậy ta cùng nhìn sâu hơn ở low-level cuả câu lệnh <code>stock--</code>, ở mức độ ngôn ngữ máy, nó được thực hiện như sau</p><pre><code class="language-shell">register = stock
register = register - 1
stock = register
</code></pre><p>Giá trị từ biến <code>stock</code> sẽ được đọc và ghi xuống thanh ghi, sau đó tiến hành tính toán bởi CPU và được ghi lại vào biến <code>stock</code>. Điều này dẫn đến việc khi hai hay nhiều truy cập đồng thời vào biến stock thì giá trị tương ứng của <code>stock</code> sẽ được ghi vào nhiều thanh ghi khác nhau với cùng một giá trị, vì thế làm cho giá trị của <code>stock</code> bị tính toán sai. Ví dụ ta có 3 Gorountines cùng truy cập vùng nhớ của <code>stock</code> và thực thi phép toán, thì lúc này giá trị của <code>stock</code> thay vì cần giảm 3 đơn vị thì nó chỉ giảm 1.</p><pre><code class="language-shell">Goroutine1: stock-- =&gt;  register1 = stock (stock=1)
                        register1 = register1 - 1
                        stock = register1 (stock = 0)
Goroutine2: stock-- =&gt;  register2 = stock (stock=1)
                        register2 = register2 - 1
                        stock = register2 (stock = 0)
Goroutine3: stock-- =&gt;  register3 = stock (stock=1)
                        register3 = register3 - 1
                        stock = register3 (stock = 0)
</code></pre><p>Đó là những gì bên dưới đã xảy ra và những điều này chúng ta sẽ không thể thấy được ở high level tức là trên những dòng code mà ta viết nên một khi gặp phải thì việc debug sẽ trở nên rất khó khăn. Và qua ví dụ ta cũng thấy vấn đề xảy ra do việc có nhiều process cùng truy cập vào một vùng một cách đồng thời đã được đề cập trong phần định nghĩa. Từ đây ta cũng biết cách để phòng tránh race condition bằng việc can thiệp để các process không được cùng truy cập vào cùng một vùng nhớ chung tại một thời điểm nhất định.</p><h3>Giải pháp</h3><p>Mời mọi người đón xem ở trong <a href="https://hung-m-dao.github.io/thao/race-condition-solution/">phần tiếp theo</a></p><h3>Read more</h3><ul><li><a href="https://en.wikipedia.org/wiki/Race_condition">Race condition</a></li><li><a href="https://codex.cs.yale.edu/avi/os-book/OS10/practice-exercises/index-solu.html">Chapter 6 - Operating System Concepts by Abraham Silberschatz, Peter B. Galvin, Greg Gagne</a></li></ul>]]></content:encoded></item><item><guid isPermaLink="true">https://hung-m-dao.github.io/hung/md-to-html</guid><title>Làm Blog bằng Publish - Xuất HTML từ file Markdown</title><description>Thay vì ngủ lúc 10h thì mình đã thức đến 1h để làm gì ?</description><link>https://hung-m-dao.github.io/hung/md-to-html</link><pubDate>Fri, 25 Mar 2022 11:55:00 +0000</pubDate><content:encoded><![CDATA[<h1>Làm Blog bằng Publish - Xuất HTML từ file Markdown</h1><p>Mình viết blog này bằng <a href="https://github.com/JohnSundell/Publish">Publish</a>, nó là một công cụ giúp tạo ra những trang web tĩnh, dành cho những lập trình viên sử dụng Swift. Chi tiết hơn về Publish sẽ được trình bày trong bài viết khác, bài viết này sẽ nói về hành trình mình tìm giải pháp xuất HTML của mình.</p><h3>Tại sao phải xuất HTML ?</h3><p>Publish vốn có thể tự động parse file Markdown thành HTML, thông qua <a href="https://github.com/JohnSundell/Ink">Ink</a> - một công cụ cũng do tác giả của Publish viết. Tuy nhiên, công cụ này còn rất nhiều thiếu sót (chính tác giả cũng nói vậy), và có rất nhiều tính năng của Markdown không parse được thành HTML (nested block, list in block,... ). Do đó mình bắt đầu đi tìm giải pháp tốt hơn để tạo ra file HTML (vì Publish cũng support raw HTML).</p><h3>Typora</h3><p>Sau khi tham khảo nhiều Markdown editor thì mình quyết định bắt đầu với <a href="https://typora.io/">Typora</a>, một công cụ được recommend rất nhiều. Typora có rất nhiều ưu điểm, như giao diện tối giản, xuất được rất nhiều định dạng file, đặc biệt có thể xuất HTML without styles - thứ mình rất cần.</p><p>Tuy nhiên, vì những nhược điểm sau, mà mình đã không chọn Typora:</p><ul>
<li>Tốn phí, $15.</li>
<li>Mình cần side panel để preview, nhưng không có option này.</li>
<li>Kiểu edit WYSIWYG làm mình khó chịu, loay hoay 2 phút cũng không xóa được 1 code block.</li>
</ul><h3>Quay đầu là bờ</h3><p>Loay hoay thêm 1 lúc với nhiều Markdown editor khác nhưng vẫn không ưng, mình nhớ ra VSCode và quyết định thử với nó. VSCode đã có sẵn rất nhiều thứ mình cần: Vim keybindings, side panel preview, theme/font configurations... . Nhưng có một thứ rất quan trọng mà VSCode đang thiếu: xuất HTML without styles.</p><p>Mình có thử google và thấy <a href="https://code.visualstudio.com/docs/languages/markdown#_compiling-markdown-into-html">hướng dẫn</a> của chính VSCode, nhưng có vẻ hơi phức tạp nên mình để lại thử sau. Sau khi thử với nhiều Markdown extension khác nhau, mình vẫn không có được kết quả như ý, vì cùng 1 lí do: những extension này không có option xuất HTML <strong>without styles</strong>. Mình đành quay lại đọc hướng dẫn &quot;chính chủ&quot;.</p><h3>markdown-it</h3><p>Đọc hướng dẫn của VSCode thì mình thấy họ dùng command <a href="https://github.com/markdown-it/markdown-it">markdown-it</a> để làm ví dụ. Mình có vào xem github thì thấy đây là một thư viện của NodeJs, có kèm theo CLI, và rất dễ sử dụng. Mình mừng như cá gặp nước và nhanh chóng bắt tay vào setup.</p><p>Sau vài sự tìm kiếm thì extension mình đã dùng là <a href="https://marketplace.visualstudio.com/items?itemName=edonet.vscode-command-runner">Command Runner</a>, nó cho phép mình bind shortcut key đến một command đã được định nghĩa trước. Đây là đoạn config mình dùng để định nghĩa command, được thêm vào file <code>settings.json</code> của VSCode:</p><pre><code class="language-json"> &quot;command-runner.terminal.name&quot;: &quot;runCommand&quot;,
    &quot;command-runner.terminal.autoClear&quot;: true,
    &quot;command-runner.terminal.autoFocus&quot;: true,
    &quot;command-runner.commands&quot;: {
        &quot;Export Markdown to HTML&quot;: &quot;cd ${fileDirname} &amp;&amp; markdown-it ${fileBasename} -o ${fileBasenameNoExtension}.html&quot;,
    },
</code></pre><p>Và để bind với shortcut thì mình đã thêm vào <code>keybindings.json</code>:</p><pre><code class="language-json">[
    {
        &quot;key&quot;: &quot;ctrl+cmd+e&quot;,
        &quot;command&quot;: &quot;command-runner.run&quot;,
        &quot;args&quot;: {
            &quot;command&quot;: &quot;Export Markdown to HTML&quot;,
            &quot;terminal&quot;: &quot;runCommand&quot;
        }
    }
]
</code></pre><p>Như vậy, mỗi lần soạn xong file Markdown, thì mình chỉ cần nhấn Ctrl+Cmd+E thì sẽ có một file HTML cùng tên được xuất ra ở cùng thư mục.</p><h3>30 chưa phải là Tết</h3><p>Tưởng chừng đã giải quyết được vấn đề và có thể đi ngủ, nhưng đời không như là mơ. Khi test thử với vài sample file thì mình đã phát hiện, <code>markdown-it</code> chưa hỗ trợ một số tính năng của Markdown, như foot-note, subscript, supscript,... . Sau khi quay lại xem document của họ, thì mình mới biết là cần dùng thêm <a href="https://github.com/markdown-it/markdown-it#syntax-extensions">syntax extensions</a> để dùng được những tính năng đó. Tuy nhiên không hề có hướng dẫn nào để load plugin cho CLI, mình tìm rất nhiều nhưng đều không có kết quả. Tới đây thì đã khá tuyệt vọng và buồn ngủ, mình đành tìm file binary của command đó xem source, hi vọng cuối. Để tìm &quot;nguồn gốc&quot; của <code>markdown-it</code>, mình dùng command:</p><pre><code class="language-bash">$ type -a markdown-it
</code></pre><p>và nhận được output <code>/usr/local/bin/markdown-it</code></p><p>Mình tìm đến directory trên và mở file binary lên, thật may là syntax dường như của JS, mình đã có thể load thêm plugin mà mình cần.</p><pre><code class="language-javascript">  md = require('..')({
    html: !options.no_html,
    xhtmlOut: false,
    typographer: options.typographer,
    linkify: options.linkify
  }).use(require('markdown-it-footnote'))
    .use(require('markdown-it-sub'))
    .use(require('markdown-it-sup'));
</code></pre><p>Voilà! Cuối cùng cũng đi ngủ được rồi.</p><h3>Kết</h3><p>Mặc dù có thể mình đã mắc phải <a href="https://en.wikipedia.org/wiki/XY_problem">XY Problem</a> khi cố đi tìm cách xuất file HTML, nhưng hành trình đi tìm giải pháp đã giúp mình học thêm và phát hiện được thêm khá nhiều thứ. Worth the effort ^^.</p>]]></content:encoded></item><item><guid isPermaLink="true">https://hung-m-dao.github.io/hung/collectors-fallacy</guid><title>Collector's fallacy</title><description>The reason why I bought 100+ games on Steam but only play ~5 of them.</description><link>https://hung-m-dao.github.io/hung/collectors-fallacy</link><pubDate>Fri, 25 Mar 2022 00:15:00 +0000</pubDate><content:encoded><![CDATA[<h1>Collector's fallacy</h1><h2>What is it ?</h2><p><strong>Collector’s Fallacy</strong><sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup> is the urge to collect something that you never use or need, but the act of collecting gives you a good feeling.
The sciene behind this, is,  each time we discover a new productivity toy, our brain sends us a jolt of <a href="https://en.wikipedia.org/wiki/Dopamine">dopamine</a> (our brain’s “reward” hormone)</p><h2>How to avoid it</h2><ul>
<li>&quot;Own&quot; before you collect</li>
</ul><p>Think it through before making any decision, take it slow.</p><ul>
<li>Purging</li>
</ul><p>Get rid of things you don't really touch. My rule of thumb: If you haven't used it in a year, throw it away.</p><ul>
<li>Measuring</li>
</ul><p>Always keep track of what you already have, remind yourself of the old items, this might help reduce the need of collecting new stuffs.</p><hr class="footnotes-sep">
<section class="footnotes">
<ol class="footnotes-list">
<li id="fn1" class="footnote-item"><p><em><a href="https://observer.com/2017/05/the-collectors-fallacy-why-we-gather-things-we-dont-need/">The Collector’s Fallacy: Why We Gather Things We Don’t Need</a></em> <a href="#fnref1" class="footnote-backref">↩︎</a></p>
</li>
</ol>
</section>
]]></content:encoded></item><item><guid isPermaLink="true">https://hung-m-dao.github.io/thao/go-interface</guid><title>GO INTERFACE</title><description>Go interface - The distinction makes the power and grace of Go</description><link>https://hung-m-dao.github.io/thao/go-interface</link><pubDate>Thu, 24 Mar 2022 16:55:00 +0000</pubDate><content:encoded><![CDATA[<h1>GO INTERFACE</h1><p>Giống như các ngôn ngữ lập trình khác, nơi mà chúng ta đều có thể tìm kiếm những khái niệm liên quan đến “Interface", với những ngôn ngữ hướng đối tượng kiểu tĩnh như Java, C# … thì cũng chính là interface, với những ngôn ngữ kiểu động thì có một khái niệm gần sát là “Duck Tying". Go interface cũng mang trong mình những đặc tính đó, nếu hiểu interface trong Java là “explicit interface" thì đối với Go nó là “implicit interface", trên hệ quy chiếu của các ngôn ngữ kiểu động thì có thể gọi Go Interface là Type-Safe Duck Typing. Điều đó nói lên điều gì ? Go không nghiêng về hẳn về một bên nào, mà ngược lại như một kẻ trung lập đứng ở giữa và chấp nhận quan điểm của cả hai trường phái, điều đó giúp cho Interface trong Go trở nên thật mạnh mẽ nhưng cũng thật tao nhã.</p><h2>1 Interface là gì và nó đang tồn tại như thể nào ?</h2><p>Để định nghĩa chính xác interface là gì không hề dễ, đây là một khái niệm gây confuse và được mô tả khác nhau ở các ngôn ngữ. Nhưng nó vẫn dựa trên một nền tảng chung nó là một kiểu thể hiện sự tổng quát hóa và trừu tượng hóa dựa trên các hành vi của các kiểu khác. Để hiểu rõ hơn ở đây mình sẽ dùng interface ở trong Java và Duck Typing trong python để làm rõ vấn đề ở trên ở mức độ ngôn ngữ</p><h3>1.1 Java Interface là Explicit Interface</h3><pre><code class="language-java">public interface Writer {
    void write(String data);
}

public class FileWriter implements Writer {
    public void write(String data) {
    // write string data to text file 
    }
}

public class Client {
    private final Writer writer;
    // this type is the interface, not the implementation

    public Client(Writer writer) {
      this.writer = writer;
    }

    public void program() {
        // get data from somewhere
        this.writer.write(data);
    }
}

public static void main(String[] args) {
    Writer writer = new FileWriter();
    Client client = new Client(writer);
    client.program();
}
</code></pre><ul><li>Trong Java khi một class muốn hiện thực một interface, thì cần phải đặc tả một cách “explicit" interface mà class đó muốn hiện thực.</li><li>Điều này có ưu điểm là tính readability cao giúp cho mọi người có thể nhanh chóng nắm bắt code đang muốn nói gì và đặc biệt với những người mói tiếp cận project.</li><li>Nhưng có một nhược điểm là tính flexible, chính vì việc cần đặc tả interface mà một class đang implement sẽ dẫn đến việc refactor code sẽ không hề dễ dàng hay có thể nói là khó khăn khi ứng dụng của chúng ta phát triển và thay đổi theo thời gian. Có thể nhìn vào đoạn code trên, giả sử chúng ta đang có <code>Writer</code> interface được import từ một thư viện vào đó, và tại thời điểm quyết định dùng nó mọi thứ rất tuyệt vời. Một thời gian sau, chúng ta có thêm requirement rằng hệ thống cần phải thêm chức năng ghi dữ liệu ra file .proto (một loại file mới xuất hiện gần đây) mà thư viện của writer interface chưa support. Vậy giải pháp ở đây là gì ? Chúng ta cần một thư viện mới hiện đại hơn có thể dùng được cho các loại file mới hơn và cũng như support các loại file đã tồn tại ở trong <code>Writer</code>, mình tạm gọi nó là <code>ModernWriter</code> interface. Tưởng chừng bài toán đã được giải quyết nhưng thật không may, nếu chuyển qua sử dụng thư viện mới này thì các đoạn code liên quan đến client cần phải được refactor để chuyển sang sử dụng interface mới hay có thể nói một cách vĩ mô hơn là client đang phụ thuộc vào các dependencies điều này đang đi ngược với nguyên tác Dependency Inversion của Uncle Bob trong SOLID, vì mỗi lần ta cần chuyển sang sử dụng thư viện mới ta lại phải can thiệp vào code của client và đó không phải là một ý kiến hay, vậy câu hỏi được đặt ra ở đây là có cách nào để giải quyết bài toán này một cách dễ dàng nhất trong Java ?</li></ul><h3>1.2 Duck Typing với Python</h3><p>Duck Typing rất phổ biến trong các ngôn ngữ kiểu động, nó được định nghĩa là một phương pháp lập trình từ ý tưởng của duck test ("If it looks like a duck, swims like a duck, and quacks like a duck, then it probably is a duck" - tạm dịch là nếu một thứ nào đó trông giống một con vịt, bơi như một con vịt, và kêu quạc quạc như vịt thì nó có thể là một con vịt). Nó có nghĩa việc lập trình của chúng ta bây giờ sẽ hướng tới hành vi của đối tượng hơn là kiểu của chúng. Vậy để hiểu rõ hơn về duck typing, mình sẽ dùng chính ví dụ ở trên được viết lại bằng Python để minh họa rõ hơn</p><pre><code class="language-python">class FileWriter:
    def write():
        #TODO: write string data to text file

class Client:
    def __init__(self, writer):
        self.writer = writer

    def program():
        # get data from somewhere
        self.writer.write(data);

file_writer = FileWriter()
client = Client(file_writer)
client.program()
</code></pre><p>Qua đoạn code trên ta có thể thấy rõ việc ngôn ngữ sử dụng duck-typing không hề quan tâm đến type của <code>writer</code> là gì, nó sẽ cố gắng tìm xem <code>writer</code> object được truyền vào có hiện thực method <code>write</code> hay không và tiến hành gọi hàm. Nghe tới đây thì ta có thể nhận ra rằng Python nói riêng và các ngôn ngữ kiểu động có thể dễ dàng giải quyết vấn đề mà các ngôn ngữ kiểu tĩnh như Java ở phần trước đã gặp phải ngay trong code. Quay lại requirement được thêm vào ở phần trên, ta cần thêm chức năng ghi ra file <code>.proto</code>, với python ta chỉ cần dễ dàng thêm (import) thư viện mà ta muốn dùng để ghi file <code>.proto</code> và truyền nó vào constructor của <code>Client</code> khi cần sử dụng.</p><pre><code class="language-python">class ProtoFileWriter:
    def write():
        #TODO: write string data to .proto file

# handle for .proto file writing
proto_file_writer = ProtoFileWriter()
client = Client(proto_file_writer)
client.program()
</code></pre><p>Nhưng không có gì là hoàn hảo, vấn đề của duck typing chính là type safeguard, vì nó không quan tâm đến kiểu của object mà thay vào đó là cố gắng đi tìm xem method đó có được hiện thực bởi object cho trước tại thời điểm runtime dẫn đén trường hợp một object gọi một method không được định nghĩa cùng với kiểu của nó sẽ dẫn tới bug. Cùng với ví dụ trên, giả sử một anh lập trình viên nào đó cũng tìm được một thư viện khác hỗ trợ việc ghi ra file proto nhưng lại không đọc kỹ docs hay vì một lý do nào đó không biết hàm mà thư viện đó cung cấp tên là <code>write_to_proto</code> chẳng hạn thay vì <code>wirte</code> nên dẫn đến chương trình bị lỗi. Điều này rất nguy hiểm vì chúng ta không có cách nào nhận ra dễ dàng tại thời điểm compile vì nó chỉ xảy ra tại thời điểm runtime, chưa kể nếu những đoạn code này không được test một cách kỹ càng thì thật sự nó sẽ thành thảm họa.</p><pre><code class="language-python">class OtherProtoFileWriter:
    def write_to_proto():
        #TODO: write string data to .proto file
        
# handle for .proto file writing
proto_file_writer = OtherProtoFileWriter()
client = Client(proto_file_writer)
client.program() # &lt;-- crashed here at runtime
</code></pre><h2>2. Go Interface</h2><p>Trong phần trước chúng ta đã có cái nhìn tổng thể về sự hiện diện của interface trong các ngôn ngữ lập trình như thế nào. Go cũng không phải là một ngoại lệ, vì Go được ra đời sau nên nó thừa kế được những điểm mạnh của các ngôn ngữ đi trước. Go chấp nhận cả hai tư tưởng ở trên vì rõ ràng các trường hợp đó xuất hiện hằng ngày trong lúc chúng ta lập trình. Vậy Go đã đưa ra giải pháp thế nào cho việc tận dụng điểm mạnh của cả hai ? Và đó là lúc implicit interface xuất hiện</p><h3>2.1 Go Interface là Implicit Interface và là Type-Safe Duck Typing</h3><p>Trước khi đào sâu vào các khía cạnh của interface trong Go, mình sẽ một lần nữa hiện thực lại ví dụ ở phần trước bằng Go code để có thể làm rõ được các vấn đề mà chúng ta đã nêu từ đầu bài viết</p><pre><code class="language-go">type Writer interface {
    write(data string)
}

type FileWriter struct {}

func (f *FileWriter) write(data string) {
    // write string data to text file
}

type Client struct {
    writer Writer
}

func (c *Client) program() {
    // get data from somewhere
    c.writer.write(data)
}

func main() {
    fileWriter := FileWriter{}
    client := Client{writer: &amp;fileWriter}
    client.program()
}
</code></pre><p>Nhìn thoáng qua phần hiện thực ở trên có ý tưởng gần giống Java, nhưng có một điểm khác biệt quan trọng là có vẻ <code>FileWriter</code> chính là kiểu đang hiện thực <code>Writer</code> interface nhưng lại không hề có sự xuất hiện của keyword <strong><code>implements</code></strong> . Và chính xác <code>FileWriter</code> đang hiện thực <code>Writer</code> interface như mọi người nghĩ, điều này nói lên Interface trong Go là <strong>Implicit Interface</strong> tức là một kiểu rời rạc (concrete type - theo cách gọi của Go) khi hiện thực bất kỳ interface nào thì không cần chỉ ra cụ thể interface mà nó hiện thực. Chính vì thế một concrete type T được xem như đang hiện thực một interface I chỉ cần thỏa điều kiện là T đang sở hữu các hàm (implementation) mà I đã định nghĩa mà không cần biết đến sự có mặt của I.</p><p><em>Khi cần thêm một writer mới</em></p><pre><code class="language-go">type ProtoFileWriter struct {}

func (f *ProtoFileWriter) write(data string) {
    // write string data to .proto file
}

func main() {
    fileWriter := FileWriter{}
    client := Client{writer: &amp;fileWriter}
    client.program()

    // for .proto file
    protoFileWriter := ProtoFileWriter{}
    client = Client{writer: &amp;protoFileWriter} 
    client.program()
}
</code></pre><p>Quay lại đoạn code ở trên, nếu ta bỏ qua phần định nghĩa interface <code>Writer</code> thì ta có thể thấy phần còn lại rất giống phần ví dụ bằng code Python ở phần trước. Cách triển khai đang thể hiện rất rõ ý tưởng của Duck Typing nhưng lại có một ưu điểm so với cách dùng ở các ngôn ngữ kiểu động nằm ở việc đảm bảo <code>writer</code> được truyền vào <code>Client</code> vẫn thuộc interface <code>Writer</code>, điều mà Python hay các ngôn ngữ kiểu động không làm được ở thời điểm compile. Đó là lý do tại sao Interface của Go cũng có thể được xem là <strong>Type-Safe Duck Typing</strong>, người sử dụng sẽ luôn biết chính xác mình đang có trong tay những thứ mình thật sự mong muốn như cách mà các ngôn ngữ kiểu tĩnh hoạt động thay vì là sự mơ hồ ở các ngôn ngữ kiểu động.</p><p><em>Khi kiểu không thuộc interface type sẽ báo lỗi tại thời điểm complie</em></p><pre><code class="language-go">type OtherProtoFileWriter struct {}

func (f *OtherProtoFileWriter) writeToProto(data string) {
    // write string data to .proto file
}

func main() {
    fileWriter := FileWriter{}
    client := Client{writer: &amp;fileWriter}
    client.program()

    protoFileWriter := OtherProtoFileWriter{}
    // Error: Cannot use '&amp;protoFileWriter' (type *OtherProtoFileWriter) as 
    // the type Writer Type does not implement 'Writer' as some 
    // methods are missing: write(data string)
    client = Client{writer: &amp;protoFileWriter} 
    client.program()
}
</code></pre><h3>2.2 Interface dưới góc nhìn của Go</h3><p>Ở phần trước mình đã làm rõ tại sao Go Interface lại được xem như là một <strong>Implicit Interface</strong> hay <strong>Type-Safe Duck Typing</strong> nhưng chưa có một định nghĩa rõ ràng, nên trong phần mình sẽ nói sâu thêm về Interface dưới góc nhìn của chính nó (Go).</p><ul><li><strong>Go Interface hay Interface type được định nghĩa là một tập hợp của các methods mà các kiểu rời rạc (concrete type) phải hiện thực để được xem như là một instance của interface đó.</strong></li><li>Interface trong Go là abstract type duy nhất.</li><li>Các kiểu thỏa mãn interface (Interface Statisfaction) nếu chúng sở hữu các methods mà interface đó yêu cầu mà không cần đặc tả interface đó.</li></ul><p>Chính vì tính flexible của Go Interface nên Go được xem như một ngôn ngữ dễ mở rộng nhưng cũng dễ maintaint vì vẫn giữ được sự mạnh mẽ của hệ thống type ở ngôn ngữ kiểu tĩnh. Ngoài ra, một điểm mạnh khác cũng giúp phát huy sức mạnh của Go chính là các standard libs mà đội ngũ các kỹ sư tại Google cung cấp. Các thư viện này được xây dựng dựa trên các Interface đã được chuẩn hóa rất tốt và được xem như nền tảng của bất kỳ lĩnh vực nào nó góp mặt. Nó khuyến khích các lập trình viên tận dụng sức mạnh của chúng để xây dựng và mở rộng các thư viện có liên quan. Nên nếu các bạn đọc qua nhiều open source được viết bằng Go, lúc nào ta cũng thấy sự xuất hiện của các Interface đến từ standard libs, điều này giúp cho ngôn ngữ trở nên thống nhất nhưng tính linh hoạt lại rất cao. Đó cũng là lý do ta có thể khó kiếm được một canonicial framework nào ở Go như ở các ngôn ngữ khác như Ruby's Rails, Python's Django, Java's Spring vì những thứ mà Go cung cấp là đủ dùng, mặc dù là không thiếu những framework với mục đích như vậy nhưng chúng cũng đều được build dựa trên các interface của thư viện chuẩn nên trong trường hợp cần ta chỉ cần gắn kết những thứ mà ta thật sự cần. Trong những bài viết sau mình sẽ đào sâu hơn vào các interface như vậy, một trong số đó là <code>http.Handler</code>, interface kinh điển mà bất kỳ lập trình viên nào khi lập trình web với Go đều phải biết.</p><h2>Kết</h2><p>Trong bài này mình đã giới thiệu sơ lược về Go Interface và đặc tính quan trọng của nó thông qua góc nhìn từ các ngôn ngữ khác. Mình chưa làm việc với Java, nhưng qua bài này mình đã hiểu thêm về Java nhưng chắc không thể không có thiếu xót nên mong nhận được thêm ý kiến và góp ý về vấn đề này. Bài khá dài, viết cũng mất rất nhiều thời gian vì mình phải đọc thêm rất nhiều tài liệu liên quan, nhưng sau khi viết xong mình càng hiểu rõ, hiểu sâu hơn và có cái nhìn rộng bao quát hơn về chủ đề này. Hy vọng bài này giúp mọi người có góc nhìn rõ hơn về Go Interface nhé!</p><h3>Read more</h3><p><a href="https://www.amazon.com/Learning-Go-Idiomatic-Real-World-Programming/dp/1492077216#:~:text=Networking%20%26%20Cloud%20Computing-,Learning%20Go%3A%20An%20Idiomatic%20Approach%20to%20Real%2DWorld%20Go%20Programming,-1st%20Edition">Learning Go: An Idiomatic Approach to Real-World Go Programming</a></p><p><a href="https://www.amazon.com/Programming-Language-Addison-Wesley-Professional-Computing/dp/0134190440">Go Programming Language, The (Addison-Wesley Professional Computing Series)</a></p><p><a href="https://en.wikipedia.org/wiki/Duck_typing">Duck Typing</a></p><p><a href="https://en.wikipedia.org/wiki/SOLID">SOLID - Dependency inversion principle</a></p>]]></content:encoded></item><item><guid isPermaLink="true">https://hung-m-dao.github.io/thao/cap</guid><title>CAP Theorem</title><description>Khi thiết kế hệ thống phân tán (distributed system) có một định lý nền tảng quan trọng đó là CAP theorem. Trong bài viết này chúng ta cùng tìm hiểu về các khía cạnh này của định lý này.</description><link>https://hung-m-dao.github.io/thao/cap</link><pubDate>Wed, 23 Mar 2022 16:55:00 +0000</pubDate><content:encoded><![CDATA[<h1>CAP Theorem</h1><p>Khi nhắc tới các hệ thống phân tán (distributed system) có một định lý nền tảng quan trọng đó là “CAP theorem"</p><h2>1 WHAT - CAP theorem là gì ?</h2><p>Định lý CAP nói rằng (ở đây xin trích dẫn nguyên văn tiếng Anh)</p><blockquote>
It is impossible for a web service to provide the following three guarantees:<br>
- Consistency <br>
- Availability <br>
- Partition-tolerance <br>
</blockquote><p>Những thuộc tính trên: consistency, availability, partition-tolerance là những yếu tố mà khi xây dựng một hệ thống phần mềm thực tế đều hướng đến. Vậy trước tiên ta cần hiểu rõ các khái niệm này.</p><h3>1.1 Consistency</h3><p>Consistency ở đây nói đến việc khi một request được gửi tới một hệ tống phân tán thì nó phải được phản hồi ngay lập tức bởi một giá trị nào đó. Và quan trọng hơn là kết quả khi thực một request để đọc dữ liệu ngay sau khi kết thúc việc ghi dữ liệu phải đảm bảo việc lấy ra dữ liệu vừa được ghi thay vì các dữ liệu trước đó (stale data). Hay hiểu đơn giản trong một hệ thống database gồm n nodes, thì sau khi hoàn tất việc ghi dữ liệu ở bất kỳ node nào, thì việc đọc dữ liệu ở tất cả các node đều cho ra một kết quả giống nhau và là chính là dữ liệu được ghi thành công sau cùng.</p><h3>1.2 Availability</h3><p>Tính khả dụng định nghĩa rằng với bất kỳ request nào được nhận bởi một node đang hoạt động trong hệ thống phải trả về một response tương ứng, điều đó có nghĩa tất cả mọi giải thuật và process bên trọng đều phải kết thúc vào một thời điểm nào đó (eventually terminate) cho dù gặp phải vấn đề gì.</p><h3>1.3 Partition-tolerance</h3><p>Thuộc tính này là điều kiện đảm bảo cho hai đăc tính trên trong hệ thống phân tán. Partition-tolerance nói rằng khi có một phần hệ thống bị sập thì hệ thống vẫn có thể trả về kết quả cho một request tương ứng. Điều cho phép việc các message được truyền tải giữa các phần (các nodes) có thể bị mất (lost) hoặc bị trì hoàn (delayed)</p><h3>Read more</h3><ul><li><a href="https://awoc.wolski.fi/dlib/big-data/GiLy02-CAP.pdf">Brewer’s Conjecture and the Feasibility of Consistent, Available, Partition-Tolerant Web Services</a></li></ul>]]></content:encoded></item><item><guid isPermaLink="true">https://hung-m-dao.github.io/hung/dunning-kruger</guid><title>Dunning-Kruger effect</title><description>"You're not as smart as you think you are"</description><link>https://hung-m-dao.github.io/hung/dunning-kruger</link><pubDate>Wed, 23 Mar 2022 10:55:00 +0000</pubDate><content:encoded><![CDATA[<h1>Dunning-Kruger effect</h1><p>The <strong>Dunning-Kruger effect</strong> is a type of cognitive bias in which people believe that they are smarter and more capable than they really are. Essentially, low ability people do not possess the skills needed to recognize their own incompetence.</p><img src="https://hung-m-dao.github.io//images/dunning-kruger.jpeg" alt="Dunning-Kruger chart"/>]]></content:encoded></item></channel></rss>